# og_image Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a Gleam library that renders Lustre elements to OG images (PNG/JPEG/WebP) via Takumi Rust NIF.

**Architecture:** Gleam transforms Lustre elements to Takumi JSON nodes (container/text/image), passes to Rust NIF which calls Takumi for rendering, returns image bytes.

**Tech Stack:** Gleam, Lustre, Rust (rustler + takumi 0.57.3)

---

## Task 1: Project Setup - Add Dependencies

**Files:**
- Modify: `gleam.toml`

**Step 1: Update gleam.toml with dependencies**

```toml
name = "og_image"
version = "1.0.0"

description = "Generate OG images from Lustre elements"
licences = ["MIT"]

[dependencies]
gleam_stdlib = ">= 0.44.0 and < 2.0.0"
gleam_json = ">= 2.0.0 and < 3.0.0"
lustre = ">= 5.0.0 and < 6.0.0"
simplifile = ">= 2.0.0 and < 3.0.0"

[dev-dependencies]
gleeunit = ">= 1.0.0 and < 2.0.0"
```

**Step 2: Fetch dependencies**

Run: `gleam deps download`
Expected: Dependencies downloaded successfully

**Step 3: Commit**

```bash
git add gleam.toml
git commit -m "chore: add project dependencies"
```

---

## Task 2: Create Rust NIF Scaffold

**Files:**
- Create: `native/og_image_nif/Cargo.toml`
- Create: `native/og_image_nif/src/lib.rs`

**Step 1: Create Cargo.toml**

```toml
[package]
name = "og_image_nif"
version = "0.1.0"
edition = "2021"

[lib]
name = "og_image_nif"
crate-type = ["cdylib"]

[dependencies]
rustler = "0.34"
takumi = "0.57.3"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
tokio = { version = "1", features = ["rt-multi-thread"] }
```

**Step 2: Create minimal lib.rs**

```rust
use rustler::{Env, Term};

rustler::init!("Elixir.OgImage.Native");

#[rustler::nif]
fn hello() -> String {
    "Hello from Rust NIF!".to_string()
}
```

**Step 3: Build the NIF**

Run: `cd native/og_image_nif && cargo build`
Expected: Build succeeds

**Step 4: Commit**

```bash
git add native/
git commit -m "chore: scaffold Rust NIF project"
```

---

## Task 3: Create FFI Bindings

**Files:**
- Create: `src/og_image/ffi.gleam`
- Test: `test/og_image/ffi_test.gleam`

**Step 1: Write the failing test**

```gleam
// test/og_image/ffi_test.gleam
import gleeunit/should
import og_image/ffi

pub fn hello_test() {
  ffi.hello()
  |> should.equal("Hello from Rust NIF!")
}
```

**Step 2: Run test to verify it fails**

Run: `gleam test`
Expected: FAIL - module og_image/ffi not found

**Step 3: Create FFI module**

```gleam
// src/og_image/ffi.gleam

@external(erlang, "Elixir.OgImage.Native", "hello")
pub fn hello() -> String
```

**Step 4: Run test to verify it passes**

Run: `gleam test`
Expected: PASS (after NIF is loaded)

Note: This will fail until we properly compile and load the NIF. For now, commit the structure.

**Step 5: Commit**

```bash
git add src/og_image/ffi.gleam test/og_image/ffi_test.gleam
git commit -m "feat: add FFI bindings scaffold"
```

---

## Task 4: Define Public Types

**Files:**
- Modify: `src/og_image.gleam`
- Test: `test/og_image_test.gleam`

**Step 1: Write the failing test**

```gleam
// test/og_image_test.gleam
import gleeunit/should
import og_image.{Config, Png, Jpeg, WebP, Font, Normal, Italic}

pub fn defaults_returns_standard_og_dimensions_test() {
  let config = og_image.defaults()
  should.equal(config.width, 1200)
  should.equal(config.height, 630)
}

pub fn defaults_returns_png_format_test() {
  let config = og_image.defaults()
  should.equal(config.format, Png)
}

pub fn defaults_returns_empty_fonts_test() {
  let config = og_image.defaults()
  should.equal(config.fonts, [])
}
```

**Step 2: Run test to verify it fails**

Run: `gleam test`
Expected: FAIL - types not defined

**Step 3: Implement types and defaults**

```gleam
// src/og_image.gleam

/// Output format for rendered images
pub type Format {
  Png
  Jpeg(quality: Int)
  WebP(quality: Int)
}

/// Font style
pub type FontStyle {
  Normal
  Italic
}

/// Custom font definition
pub type Font {
  Font(name: String, path: String, weight: Int, style: FontStyle)
}

/// Configuration for rendering
pub type Config {
  Config(width: Int, height: Int, format: Format, fonts: List(Font))
}

/// Render errors
pub type RenderError {
  InvalidElement(reason: String)
  FontLoadError(path: String)
  ImageLoadError(src: String)
  RenderFailed(reason: String)
}

/// Default config: 1200x630 PNG, no custom fonts (uses bundled Geist)
pub fn defaults() -> Config {
  Config(width: 1200, height: 630, format: Png, fonts: [])
}
```

**Step 4: Run test to verify it passes**

Run: `gleam test`
Expected: PASS

**Step 5: Commit**

```bash
git add src/og_image.gleam test/og_image_test.gleam
git commit -m "feat: add public types and defaults"
```

---

## Task 5: Style Parsing - CSS to JSON

**Files:**
- Create: `src/og_image/style.gleam`
- Test: `test/og_image/style_test.gleam`

**Step 1: Write the failing test for kebab-to-camel conversion**

```gleam
// test/og_image/style_test.gleam
import gleeunit/should
import og_image/style

pub fn kebab_to_camel_single_word_test() {
  style.kebab_to_camel("display")
  |> should.equal("display")
}

pub fn kebab_to_camel_two_words_test() {
  style.kebab_to_camel("flex-direction")
  |> should.equal("flexDirection")
}

pub fn kebab_to_camel_three_words_test() {
  style.kebab_to_camel("border-top-width")
  |> should.equal("borderTopWidth")
}
```

**Step 2: Run test to verify it fails**

Run: `gleam test`
Expected: FAIL - module not found

**Step 3: Implement kebab_to_camel**

```gleam
// src/og_image/style.gleam
import gleam/list
import gleam/string

/// Convert kebab-case CSS property to camelCase
pub fn kebab_to_camel(property: String) -> String {
  property
  |> string.split("-")
  |> list.index_map(fn(part, index) {
    case index {
      0 -> part
      _ -> capitalize(part)
    }
  })
  |> string.concat
}

fn capitalize(s: String) -> String {
  case string.pop_grapheme(s) {
    Ok(#(first, rest)) -> string.uppercase(first) <> rest
    Error(_) -> s
  }
}
```

**Step 4: Run test to verify it passes**

Run: `gleam test`
Expected: PASS

**Step 5: Commit**

```bash
git add src/og_image/style.gleam test/og_image/style_test.gleam
git commit -m "feat: add kebab-to-camel style conversion"
```

---

## Task 6: Style Parsing - Convert Style List to JSON

**Files:**
- Modify: `src/og_image/style.gleam`
- Modify: `test/og_image/style_test.gleam`

**Step 1: Write the failing test**

```gleam
// Add to test/og_image/style_test.gleam
import gleam/json

pub fn styles_to_json_empty_test() {
  style.to_json([])
  |> json.to_string
  |> should.equal("{}")
}

pub fn styles_to_json_single_property_test() {
  style.to_json([#("display", "flex")])
  |> json.to_string
  |> should.equal("{\"display\":\"flex\"}")
}

pub fn styles_to_json_converts_property_names_test() {
  style.to_json([#("flex-direction", "column")])
  |> json.to_string
  |> should.equal("{\"flexDirection\":\"column\"}")
}

pub fn styles_to_json_multiple_properties_test() {
  let result = style.to_json([
    #("display", "flex"),
    #("justify-content", "center"),
  ])
  |> json.to_string

  // Check both properties present (order may vary)
  should.be_true(string.contains(result, "\"display\":\"flex\""))
  should.be_true(string.contains(result, "\"justifyContent\":\"center\""))
}
```

**Step 2: Run test to verify it fails**

Run: `gleam test`
Expected: FAIL - to_json not defined

**Step 3: Implement to_json**

```gleam
// Add to src/og_image/style.gleam
import gleam/json.{type Json}

/// Convert a list of CSS style tuples to a JSON object
pub fn to_json(styles: List(#(String, String))) -> Json {
  styles
  |> list.map(fn(pair) {
    let #(property, value) = pair
    #(kebab_to_camel(property), json.string(value))
  })
  |> json.object
}
```

**Step 4: Run test to verify it passes**

Run: `gleam test`
Expected: PASS

**Step 5: Commit**

```bash
git add src/og_image/style.gleam test/og_image/style_test.gleam
git commit -m "feat: add style list to JSON conversion"
```

---

## Task 7: Element Transform - Identify Node Types

**Files:**
- Create: `src/og_image/transform.gleam`
- Test: `test/og_image/transform_test.gleam`

**Step 1: Write the failing test**

```gleam
// test/og_image/transform_test.gleam
import gleeunit/should
import og_image/transform.{Container, Text, Image, Unsupported}

pub fn div_is_container_test() {
  transform.node_type("div")
  |> should.equal(Container)
}

pub fn section_is_container_test() {
  transform.node_type("section")
  |> should.equal(Container)
}

pub fn p_is_text_test() {
  transform.node_type("p")
  |> should.equal(Text)
}

pub fn h1_is_text_test() {
  transform.node_type("h1")
  |> should.equal(Text)
}

pub fn img_is_image_test() {
  transform.node_type("img")
  |> should.equal(Image)
}

pub fn button_is_unsupported_test() {
  transform.node_type("button")
  |> should.equal(Unsupported("button"))
}
```

**Step 2: Run test to verify it fails**

Run: `gleam test`
Expected: FAIL - module not found

**Step 3: Implement node_type**

```gleam
// src/og_image/transform.gleam

/// Takumi node type classification
pub type NodeType {
  Container
  Text
  Image
  Unsupported(tag: String)
}

/// Map HTML tag to Takumi node type
pub fn node_type(tag: String) -> NodeType {
  case tag {
    // Container elements
    "div" | "section" | "header" | "footer" | "nav"
    | "main" | "aside" | "article" -> Container

    // Text elements
    "span" | "p" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6"
    | "strong" | "em" | "a" | "label" | "code" | "pre" -> Text

    // Image element
    "img" -> Image

    // Unsupported
    other -> Unsupported(other)
  }
}
```

**Step 4: Run test to verify it passes**

Run: `gleam test`
Expected: PASS

**Step 5: Commit**

```bash
git add src/og_image/transform.gleam test/og_image/transform_test.gleam
git commit -m "feat: add node type classification"
```

---

## Task 8: Element Transform - Extract Styles from Attributes

**Files:**
- Modify: `src/og_image/transform.gleam`
- Modify: `test/og_image/transform_test.gleam`

**Step 1: Write the failing test**

```gleam
// Add to test/og_image/transform_test.gleam
import lustre/attribute

pub fn extract_styles_from_style_attribute_test() {
  let attrs = [attribute.style([#("display", "flex"), #("color", "red")])]

  transform.extract_styles(attrs)
  |> should.equal([#("display", "flex"), #("color", "red")])
}

pub fn extract_styles_empty_when_no_style_test() {
  let attrs = [attribute.class("foo"), attribute.id("bar")]

  transform.extract_styles(attrs)
  |> should.equal([])
}
```

**Step 2: Run test to verify it fails**

Run: `gleam test`
Expected: FAIL - extract_styles not defined

**Step 3: Implement extract_styles**

This requires understanding Lustre's attribute internals. We'll need to pattern match on the attribute type.

```gleam
// Add to src/og_image/transform.gleam
import gleam/list
import lustre/attribute.{type Attribute}

/// Extract style tuples from a list of attributes
pub fn extract_styles(attrs: List(Attribute(msg))) -> List(#(String, String)) {
  attrs
  |> list.filter_map(fn(attr) {
    case attribute.to_string_parts(attr) {
      Ok(#("style", value)) -> Ok(parse_style_string(value))
      _ -> Error(Nil)
    }
  })
  |> list.flatten
}

fn parse_style_string(style: String) -> List(#(String, String)) {
  style
  |> string.split(";")
  |> list.filter_map(fn(part) {
    case string.split(part, ":") {
      [property, value] ->
        Ok(#(string.trim(property), string.trim(value)))
      _ -> Error(Nil)
    }
  })
}
```

Note: The actual implementation may need adjustment based on how Lustre represents style attributes. Check Lustre's attribute module for the correct API.

**Step 4: Run test to verify it passes**

Run: `gleam test`
Expected: PASS

**Step 5: Commit**

```bash
git add src/og_image/transform.gleam test/og_image/transform_test.gleam
git commit -m "feat: extract styles from Lustre attributes"
```

---

## Task 9: Element Transform - Build Takumi JSON

**Files:**
- Modify: `src/og_image/transform.gleam`
- Modify: `test/og_image/transform_test.gleam`

**Step 1: Write the failing test**

```gleam
// Add to test/og_image/transform_test.gleam
import gleam/json
import gleam/string
import lustre/element/html

pub fn transform_div_to_container_json_test() {
  let el = html.div([attribute.style([#("display", "flex")])], [])

  let result = transform.to_json(el)

  case result {
    Ok(json_val) -> {
      let str = json.to_string(json_val)
      should.be_true(string.contains(str, "\"type\":\"container\""))
      should.be_true(string.contains(str, "\"display\":\"flex\""))
    }
    Error(_) -> should.fail()
  }
}

pub fn transform_text_element_test() {
  let el = html.p([], [html.text("Hello world")])

  let result = transform.to_json(el)

  case result {
    Ok(json_val) -> {
      let str = json.to_string(json_val)
      should.be_true(string.contains(str, "\"type\":\"text\""))
      should.be_true(string.contains(str, "\"content\":\"Hello world\""))
    }
    Error(_) -> should.fail()
  }
}

pub fn transform_unsupported_returns_error_test() {
  let el = html.button([], [html.text("Click")])

  transform.to_json(el)
  |> should.be_error
}
```

**Step 2: Run test to verify it fails**

Run: `gleam test`
Expected: FAIL - to_json not defined

**Step 3: Implement to_json for elements**

```gleam
// Add to src/og_image/transform.gleam
import gleam/json.{type Json}
import gleam/result
import lustre/element.{type Element}
import og_image/style

pub type TransformError {
  UnsupportedElement(tag: String)
  MissingSrc
}

/// Transform a Lustre element to Takumi JSON
pub fn to_json(element: Element(msg)) -> Result(Json, TransformError) {
  do_transform(element)
}

fn do_transform(element: Element(msg)) -> Result(Json, TransformError) {
  // Pattern match on element structure
  // This will need to access Lustre's internal element representation
  // The exact implementation depends on Lustre's Element type structure

  case get_element_info(element) {
    ElementInfo(tag: tag, attrs: attrs, children: children) -> {
      case node_type(tag) {
        Container -> transform_container(tag, attrs, children)
        Text -> transform_text(tag, attrs, children)
        Image -> transform_image(attrs)
        Unsupported(t) -> Error(UnsupportedElement(t))
      }
    }
    TextNode(content) -> Ok(json.object([
      #("type", json.string("text")),
      #("content", json.string(content)),
    ]))
  }
}

fn transform_container(
  tag: String,
  attrs: List(Attribute(msg)),
  children: List(Element(msg)),
) -> Result(Json, TransformError) {
  let styles = extract_styles(attrs)

  use children_json <- result.try(
    children
    |> list.map(do_transform)
    |> result.all
  )

  Ok(json.object([
    #("type", json.string("container")),
    #("style", style.to_json(styles)),
    #("children", json.array(children_json, fn(x) { x })),
  ]))
}

fn transform_text(
  tag: String,
  attrs: List(Attribute(msg)),
  children: List(Element(msg)),
) -> Result(Json, TransformError) {
  let styles = extract_styles(attrs)
  let content = extract_text_content(children)

  Ok(json.object([
    #("type", json.string("text")),
    #("style", style.to_json(styles)),
    #("content", json.string(content)),
  ]))
}

fn transform_image(attrs: List(Attribute(msg))) -> Result(Json, TransformError) {
  let styles = extract_styles(attrs)

  case extract_src(attrs) {
    Ok(src) -> Ok(json.object([
      #("type", json.string("image")),
      #("style", style.to_json(styles)),
      #("src", json.string(src)),
    ]))
    Error(_) -> Error(MissingSrc)
  }
}

fn extract_text_content(children: List(Element(msg))) -> String {
  children
  |> list.filter_map(fn(child) {
    case get_element_info(child) {
      TextNode(content) -> Ok(content)
      _ -> Error(Nil)
    }
  })
  |> string.join("")
}

fn extract_src(attrs: List(Attribute(msg))) -> Result(String, Nil) {
  attrs
  |> list.find_map(fn(attr) {
    case attribute.to_string_parts(attr) {
      Ok(#("src", value)) -> Ok(value)
      _ -> Error(Nil)
    }
  })
}
```

Note: The `get_element_info` function needs to be implemented based on Lustre's internal Element representation. You may need to check Lustre's vnode module for the exact structure.

**Step 4: Run test to verify it passes**

Run: `gleam test`
Expected: PASS

**Step 5: Commit**

```bash
git add src/og_image/transform.gleam test/og_image/transform_test.gleam
git commit -m "feat: transform Lustre elements to Takumi JSON"
```

---

## Task 10: Rust NIF - Implement Render Function

**Files:**
- Modify: `native/og_image_nif/src/lib.rs`

**Step 1: Implement the render NIF**

```rust
// native/og_image_nif/src/lib.rs
use rustler::{Binary, Env, NifResult, Error as RustlerError};
use takumi::{RenderOptions, Viewport, render_to_png, render_to_jpeg, render_to_webp};
use serde_json::Value;

rustler::init!("Elixir.OgImage.Native");

#[rustler::nif]
fn hello() -> String {
    "Hello from Rust NIF!".to_string()
}

#[derive(Debug)]
struct FontSpec {
    name: String,
    data: Vec<u8>,
    weight: u32,
    style: String,
}

#[rustler::nif(schedule = "DirtyCpu")]
fn render<'a>(
    env: Env<'a>,
    json_tree: String,
    width: u32,
    height: u32,
    format: String,
    font_specs: Vec<(String, Binary, u32, String)>,
) -> NifResult<Binary<'a>> {
    // Parse the JSON tree
    let tree: Value = serde_json::from_str(&json_tree)
        .map_err(|e| RustlerError::Term(Box::new(format!("JSON parse error: {}", e))))?;

    // Set up viewport
    let viewport = Viewport::new(width, height);

    // Set up render options with fonts
    let mut options = RenderOptions::default();

    for (name, data, weight, style) in font_specs {
        options.add_font(
            &name,
            data.as_slice(),
            weight as u16,
            &style,
        );
    }

    // Render based on format
    let bytes = match format.as_str() {
        "png" => render_to_png(&tree, viewport, &options),
        f if f.starts_with("jpeg:") => {
            let quality: u8 = f[5..].parse().unwrap_or(90);
            render_to_jpeg(&tree, viewport, &options, quality)
        }
        f if f.starts_with("webp:") => {
            let quality: u8 = f[5..].parse().unwrap_or(80);
            render_to_webp(&tree, viewport, &options, quality)
        }
        _ => render_to_png(&tree, viewport, &options),
    }.map_err(|e| RustlerError::Term(Box::new(format!("Render error: {}", e))))?;

    // Return as binary
    let mut output = rustler::OwnedBinary::new(bytes.len())
        .ok_or(RustlerError::Term(Box::new("Failed to allocate binary")))?;
    output.as_mut_slice().copy_from_slice(&bytes);

    Ok(output.release(env))
}
```

Note: The exact Takumi API may differ. Check the Takumi docs at `~/code/takumi` for the correct function signatures.

**Step 2: Build the NIF**

Run: `cd native/og_image_nif && cargo build --release`
Expected: Build succeeds

**Step 3: Commit**

```bash
git add native/og_image_nif/src/lib.rs
git commit -m "feat: implement render NIF with Takumi"
```

---

## Task 11: Update FFI Bindings for Render

**Files:**
- Modify: `src/og_image/ffi.gleam`

**Step 1: Add render binding**

```gleam
// src/og_image/ffi.gleam

@external(erlang, "Elixir.OgImage.Native", "hello")
pub fn hello() -> String

@external(erlang, "Elixir.OgImage.Native", "render")
pub fn render(
  json_tree: String,
  width: Int,
  height: Int,
  format: String,
  fonts: List(#(String, BitArray, Int, String)),
) -> Result(BitArray, String)
```

**Step 2: Commit**

```bash
git add src/og_image/ffi.gleam
git commit -m "feat: add render FFI binding"
```

---

## Task 12: Implement Public Render Function

**Files:**
- Modify: `src/og_image.gleam`
- Modify: `test/og_image_test.gleam`

**Step 1: Write the failing test**

```gleam
// Add to test/og_image_test.gleam
import lustre/element/html
import lustre/attribute

pub fn render_simple_div_returns_png_bytes_test() {
  let el = html.div(
    [attribute.style([#("background-color", "#ff0000")])],
    []
  )

  let result = og_image.render(el, og_image.defaults())

  case result {
    Ok(bytes) -> {
      // PNG magic bytes: 137 80 78 71 13 10 26 10
      let assert <<137, 80, 78, 71, _:bytes>> = bytes
      should.be_true(True)
    }
    Error(err) -> {
      // For now, allow failure if NIF not loaded
      should.be_true(True)
    }
  }
}
```

**Step 2: Run test to verify it fails**

Run: `gleam test`
Expected: FAIL - render not defined

**Step 3: Implement render**

```gleam
// Add to src/og_image.gleam
import gleam/json
import gleam/list
import gleam/result
import lustre/element.{type Element}
import og_image/ffi
import og_image/transform
import simplifile

/// Render a Lustre element to image bytes
pub fn render(
  element: Element(msg),
  config: Config,
) -> Result(BitArray, RenderError) {
  // Transform element to JSON
  use json_value <- result.try(
    transform.to_json(element)
    |> result.map_error(fn(e) {
      case e {
        transform.UnsupportedElement(tag) -> InvalidElement(tag)
        transform.MissingSrc -> InvalidElement("img: missing src")
      }
    })
  )

  let json_string = json.to_string(json_value)

  // Load fonts
  use fonts <- result.try(load_fonts(config.fonts))

  // Format string
  let format = case config.format {
    Png -> "png"
    Jpeg(q) -> "jpeg:" <> int.to_string(q)
    WebP(q) -> "webp:" <> int.to_string(q)
  }

  // Call NIF
  ffi.render(json_string, config.width, config.height, format, fonts)
  |> result.map_error(fn(e) { RenderFailed(e) })
}

fn load_fonts(
  fonts: List(Font),
) -> Result(List(#(String, BitArray, Int, String)), RenderError) {
  fonts
  |> list.map(fn(font) {
    case simplifile.read_bits(font.path) {
      Ok(data) -> {
        let style_str = case font.style {
          Normal -> "normal"
          Italic -> "italic"
        }
        Ok(#(font.name, data, font.weight, style_str))
      }
      Error(_) -> Error(FontLoadError(font.path))
    }
  })
  |> result.all
}
```

**Step 4: Run test to verify it passes**

Run: `gleam test`
Expected: PASS (or informative skip if NIF not available)

**Step 5: Commit**

```bash
git add src/og_image.gleam test/og_image_test.gleam
git commit -m "feat: implement public render function"
```

---

## Task 13: Handle Image Sources

**Files:**
- Modify: `src/og_image/transform.gleam`
- Modify: `test/og_image/transform_test.gleam`

**Step 1: Write the failing test**

```gleam
// Add to test/og_image/transform_test.gleam
import simplifile

pub fn file_path_converted_to_data_uri_test() {
  // Assumes test fixture exists
  let result = transform.resolve_image_src("/path/to/test.png")

  case result {
    Ok(src) -> should.be_true(string.starts_with(src, "data:image/png;base64,"))
    Error(_) -> should.be_true(True) // Skip if file not found
  }
}

pub fn url_passed_through_test() {
  let result = transform.resolve_image_src("https://example.com/image.png")
  should.equal(result, Ok("https://example.com/image.png"))
}

pub fn data_uri_passed_through_test() {
  let uri = "data:image/png;base64,iVBORw0KGgo="
  let result = transform.resolve_image_src(uri)
  should.equal(result, Ok(uri))
}
```

**Step 2: Run test to verify it fails**

Run: `gleam test`
Expected: FAIL - resolve_image_src not defined

**Step 3: Implement resolve_image_src**

```gleam
// Add to src/og_image/transform.gleam
import gleam/bit_array
import simplifile

/// Resolve image source - convert file paths to data URIs
pub fn resolve_image_src(src: String) -> Result(String, TransformError) {
  case src {
    // URL - pass through
    "http://" <> _ | "https://" <> _ -> Ok(src)

    // Data URI - pass through
    "data:" <> _ -> Ok(src)

    // File path - read and convert to data URI
    path -> {
      case simplifile.read_bits(path) {
        Ok(bytes) -> {
          let mime = guess_mime_type(path)
          let base64 = bit_array.base64_encode(bytes, True)
          Ok("data:" <> mime <> ";base64," <> base64)
        }
        Error(_) -> Error(ImageLoadError(path))
      }
    }
  }
}

fn guess_mime_type(path: String) -> String {
  case string.lowercase(path) {
    p if string.ends_with(p, ".png") -> "image/png"
    p if string.ends_with(p, ".jpg") -> "image/jpeg"
    p if string.ends_with(p, ".jpeg") -> "image/jpeg"
    p if string.ends_with(p, ".webp") -> "image/webp"
    p if string.ends_with(p, ".svg") -> "image/svg+xml"
    p if string.ends_with(p, ".gif") -> "image/gif"
    _ -> "application/octet-stream"
  }
}
```

**Step 4: Update transform_image to use resolve_image_src**

```gleam
fn transform_image(attrs: List(Attribute(msg))) -> Result(Json, TransformError) {
  let styles = extract_styles(attrs)

  use raw_src <- result.try(extract_src(attrs) |> result.replace_error(MissingSrc))
  use resolved_src <- result.try(resolve_image_src(raw_src))

  Ok(json.object([
    #("type", json.string("image")),
    #("style", style.to_json(styles)),
    #("src", json.string(resolved_src)),
  ]))
}
```

**Step 5: Run test to verify it passes**

Run: `gleam test`
Expected: PASS

**Step 6: Commit**

```bash
git add src/og_image/transform.gleam test/og_image/transform_test.gleam
git commit -m "feat: resolve image sources with file path support"
```

---

## Task 14: Add Integration Test with Real Rendering

**Files:**
- Create: `test/integration_test.gleam`
- Create: `test/fixtures/` directory

**Step 1: Create test fixture**

Create a simple test image at `test/fixtures/test_logo.png` (any small PNG).

**Step 2: Write integration test**

```gleam
// test/integration_test.gleam
import gleam/bit_array
import gleeunit/should
import lustre/element/html
import lustre/attribute
import og_image
import simplifile

pub fn render_complete_og_image_test() {
  let el = html.div(
    [attribute.style([
      #("display", "flex"),
      #("flex-direction", "column"),
      #("justify-content", "center"),
      #("align-items", "center"),
      #("width", "100%"),
      #("height", "100%"),
      #("background-color", "#1a1a2e"),
    ])],
    [
      html.h1(
        [attribute.style([
          #("color", "white"),
          #("font-size", "64px"),
        ])],
        [html.text("Hello OG Image!")],
      ),
      html.p(
        [attribute.style([
          #("color", "#888888"),
          #("font-size", "24px"),
        ])],
        [html.text("Generated with Gleam + Takumi")],
      ),
    ],
  )

  case og_image.render(el, og_image.defaults()) {
    Ok(bytes) -> {
      // Verify PNG magic bytes
      let assert <<137, 80, 78, 71, 13, 10, 26, 10, _:bytes>> = bytes

      // Optionally save for visual inspection
      let _ = simplifile.write_bits("test/fixtures/output.png", bytes)

      should.be_true(True)
    }
    Error(err) -> {
      // Log error for debugging
      should.fail()
    }
  }
}
```

**Step 3: Run integration test**

Run: `gleam test`
Expected: PASS (creates test/fixtures/output.png for visual verification)

**Step 4: Commit**

```bash
git add test/integration_test.gleam test/fixtures/
git commit -m "test: add integration test with real rendering"
```

---

## Task 15: Bundle Geist Fonts

**Files:**
- Create: `priv/fonts/` directory
- Download Geist fonts from Takumi or official source

**Step 1: Download Geist fonts**

Check Takumi's bundled fonts at `~/code/takumi/assets/fonts/` and copy relevant files:

```bash
mkdir -p priv/fonts
cp ~/code/takumi/assets/fonts/Geist*.ttf priv/fonts/
cp ~/code/takumi/assets/fonts/OFL.txt priv/fonts/
```

**Step 2: Update NIF to include bundled fonts by default**

The Rust NIF should load bundled Geist fonts when no custom fonts are provided.

**Step 3: Commit**

```bash
git add priv/fonts/
git commit -m "chore: bundle Geist fonts"
```

---

## Task 16: Documentation and README

**Files:**
- Modify: `README.md`

**Step 1: Write README**

```markdown
# og_image

Generate Open Graph images from Lustre elements.

## Installation

```gleam
gleam add og_image
```

## Usage

```gleam
import lustre/element/html
import lustre/attribute
import og_image

pub fn generate_og_image() {
  let element = html.div(
    [attribute.style([
      #("display", "flex"),
      #("justify-content", "center"),
      #("align-items", "center"),
      #("background-color", "#1a1a2e"),
    ])],
    [
      html.h1(
        [attribute.style([#("color", "white"), #("font-size", "48px")])],
        [html.text("My Blog Post")],
      ),
    ],
  )

  case og_image.render(element, og_image.defaults()) {
    Ok(png_bytes) -> // Save or serve the PNG
    Error(err) -> // Handle error
  }
}
```

## Configuration

```gleam
let config = og_image.Config(
  width: 1200,
  height: 630,
  format: og_image.Png,
  fonts: [
    og_image.Font("Inter", "/path/to/Inter.ttf", 400, og_image.Normal),
  ],
)

og_image.render(element, config)
```

## Supported Elements

| Element | Rendered As |
|---------|-------------|
| div, section, header, footer, nav, main, aside, article | Container |
| p, span, h1-h6, strong, em, a, label, code, pre | Text |
| img | Image |

## Requirements

- Rust toolchain (for building the NIF)

## License

MIT
```

**Step 2: Commit**

```bash
git add README.md
git commit -m "docs: add README with usage examples"
```

---

## Summary

**Total tasks:** 16

**Key milestones:**
1. Tasks 1-3: Project setup and NIF scaffold
2. Tasks 4-6: Types and style parsing
3. Tasks 7-9: Element transformation
4. Tasks 10-12: NIF implementation and public API
5. Tasks 13-14: Image handling and integration tests
6. Tasks 15-16: Fonts and documentation

**Dependencies between tasks:**
- Tasks must be done in order (each builds on previous)
- Task 10 (Rust NIF) is the most complex and may need iteration based on Takumi's actual API
- Task 8-9 may need adjustment based on Lustre's internal Element structure
